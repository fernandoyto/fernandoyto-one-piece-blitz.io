    // let randomItemIndex = Math.floor(Math.random() * copyItemList.length);
    // let randomColorIndex = Math.floor(Math.random() * copyColorList.length);

    // this.item1 = copyItemList[randomItemIndex];
    // this.color1 = copyColorList[randomColorIndex];

    // if (randomItemIndex !== randomColorIndex) {
    //   /* if the first item-color combination does not have fully correct properties,
    //   just pick random properties again
    //   but excluding indices alreadu used in first combination */
    //   randomItemIndex = Math.floor(Math.random() * copyItemList.length);
    //   randomColorIndex = Math.floor(Math.random() * copyColorList.length);
      
    //   this.item2 = copyItemList[randomItemIndex];
    //   this.color2 = copyColorList[randomColorIndex];
    // } else {
    //   /* however, if first item-color combination does have fully correct properties,
    //   then I have to guarantee that next combination will not be correct */
    //   copyItemList.splice(randomItemIndex, 1);
    //   copyColorList.splice(randomColorIndex, 1);
    //   do {
    //     randomItemIndex = Math.floor(Math.random() * copyItemList.length);
    //     randomColorIndex = Math.floor(Math.random() * copyColorList.length);
    //   }
    //   while (randomItemIndex === randomColorIndex);
    //   this.item2 = copyItemList[randomItemIndex];
    //   this.color2 = copyColorList[randomColorIndex];
    // }